<meta charset="UTF-8">
<html lang="en" ng-app="test" >
    <style>
      body {background-color: black;}
      input[type=text] {
      width: 100%;
      height: 100px;
      padding: 12px 20px;
      margin: 8px 0;
      background-color:rgba(0, 0, 0, 0);
      color:white;
      border: none;
      outline:none;
      font-size:24px;
      text-align: center;
    }
    .button {
      background-color: #111111;
      border: none;
      width: 100%;
      color: white;
      padding: 15px 32px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
    }
    .center {
      position: absolute;
      left: 50%;
      top: 50%;
      text-align: center;
      width:546px;
      height:265px;
      margin-left: -273px; /*half width*/
      margin-top: -132px; /*half height*/
    }

    .spinner {
      position: absolute;
      left: 50%;
      top: 50%;
      text-align: center;
      width:265px;
      height:265px;
      margin-left: -132px; /*half width*/
      margin-top: -132px; /*half height*/
    }

    .double-bounce1, .double-bounce2 {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: #333;
      opacity: 0.6;
      position: absolute;
      top: 0;
      left: 0;

      -webkit-animation: sk-bounce 2.0s infinite ease-in-out;
      animation: sk-bounce 2.0s infinite ease-in-out;
    }

    .double-bounce2 {
      -webkit-animation-delay: -1.0s;
      animation-delay: -1.0s;
    }

    .test {
      color: white;
      text-align: right;

    }

    @-webkit-keyframes sk-bounce {
      0%, 100% { -webkit-transform: scale(0.0) }
      50% { -webkit-transform: scale(1.0) }
    }

    @keyframes sk-bounce {
      0%, 100% {
        transform: scale(0.0);
        -webkit-transform: scale(0.0);
      } 50% {
        transform: scale(1.0);
        -webkit-transform: scale(1.0);
      }
    }
    label
    {
      background-color:#ffffff;
      padding: 5px 12px;
      margin: 20px 20px;
      height: 20px;
      display: inline-block;
    }

    input[type=radio]
    {
      display:none;
      padding: 5px 12px;
    }
    input[type=radio]:checked + label
    {
      background-color:#8e8e8e;
    }
    #hud {
      position: absolute;
      padding: 10px 10px;
      width: 100%;
      text-align: right;
      color: black;
    }
    .radiotext {
      margin: 0px 0px;
    }

    </style>
    <body ng-controller="PostCtrl">

      <div id="cont" class="center" style="background-color:black;">

        <input type="text" id="inputajax" list="json-datalist" placeholder="Enter your postcode" ng-change="change(select)" ng-model="select" ng-trim="false">

        <datalist id="json-datalist"></datalist>

        <button ng-click="test()" class="button">Submit</button>

      </div>
      <div hidden>
            <canvas id="myCanvas" width="1280" height="1280" crossOrigin="anonymous"></canvas>
      </div>

      <div id="hud" >

      </div>

      <div id="spin" class="spinner">
        <div class="double-bounce1"></div>
        <div class="double-bounce2"></div>
      </div>
      <script>
      var spi = document.getElementById('spin');
      spi.style.display = "none";

      var hud = document.getElementById('hud');
      hud.style.display = "none";

      var dataTypes = ["Population density", "House prices", "Crime", "Unemployment","Test1"];

      var hudFormNode = document.createElement("form");

      for (var i = 0; i < dataTypes.length; i++) {
        var trNode = document.createElement("TR");
        var tdNode = document.createElement("TD");
        var divNode = document.createElement("DIV");
        divNode.classList.add("radiotext");
        var input = document.createElement("input");
        input.type = "radio";
        input.id = i + 1 + dataTypes.length;
        input.name = "name1";
        input.value = i + 1 + dataTypes.length;
        var label = document.createElement("label");
        label.htmlFor = i + 1 + dataTypes.length;
        var textNode = document.createTextNode(dataTypes[i]);
        var att = document.createAttribute("ng-click");
        att.value = "tFunction(" + i + ")";
        input.setAttributeNode(att);

        label.appendChild(textNode);
        divNode.appendChild(input);
        divNode.appendChild(label);
        tdNode.appendChild(divNode);
        trNode.appendChild(tdNode);

        hudFormNode.appendChild(trNode);
      }

      hud.appendChild(hudFormNode);

      var container = document.getElementById('cont');

      containerFormNode = document.createElement("form");

      for (var i = 0; i < dataTypes.length; i++) {
        var input = document.createElement("input");
        input.type = "radio";
        input.id = i + 1;
        input.class = "rad";
        input.name = "name";
        input.value = i.toString();

        var label = document.createElement("label");
        label.htmlFor = i + 1;
        var textNode = document.createTextNode(dataTypes[i]);

        label.appendChild(textNode);

        containerFormNode.appendChild(input);
        containerFormNode.appendChild(label);

      }

      container.appendChild(containerFormNode);
      </script>
      <script src="../tjs/build/three.js"></script>
      <script src="../tjs/examples/js/controls/OrbitControls.js"></script>
      <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js"></script>


      <!-- from here -->
      <script>

      var app = angular.module('test', []);
      var input = document.getElementById('inputajax');
      //var container = document.getElementById('cont');
      var dataList = document.getElementById('json-datalist');
      var camera, scene, renderer;
      var mesh;
      var coords;
      var c=document.getElementById("myCanvas");
      var postcodeInfo;
      var lat, long;
      var xoffset, yoffset, xspan, yspan;
      var xtop, ytop, xbottom, ybottom;
      var pngNames = [];
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var meshes = [];
      var mergedGeo;
      var firstFrame;
      var spi = document.getElementById('spin');
      var hud = document.getElementById('hud');
      var rebuild;
      var statType;

      //var mergedGeo;
      app.controller('PostCtrl', function($scope, $http) {
        $scope.select = "";

        $scope.tFunction = function(s) {
          alert(s);
          statType = s;
          $scope.test();
        }

        $scope.test = function() {
          var val = document.getElementById('inputajax').value;
          spi.style.display = "block";
          container.style.display = "none";


          rebuild = false;

          if (typeof scene != 'undefined') {
            rebuild = true;
            while (scene.children.length > 0) {
              scene.remove(scene.children[0]);
            }
          }
          //alert(rebuild);


          var selection = document.forms[0];
          var hudRad = document.forms[1];

          if (!rebuild) {
            for (var i = 0; i < selection.length; i++) {
              //alert(selection[i].value);
              if (selection[i].checked) {
                statType = selection[i].value;
              }
            }
          }


          hudRad[statType].checked = true;

          if (rebuild) {
            meshes = [];
            init();
          }
          else {
            $http({
              method: 'POST',
              url: 'init.php',
              data: val,
              headers: {'Content-Type': 'application/x-www-form-urlencoded'}
            }).then(function(response) {
              console.log(response);

              for (var i = 0; i < 25; i++) {
                pngNames.push(response.data[i])
              }

              lat = response.data[25];
              long = response.data[26];
              xoffset = response.data[27];
              yoffset = response.data[28];
              xspan = response.data[29];
              yspan = response.data[30];
              xtile = response.data[31];
              ytile = response.data[32];
              xraw = response.data[33];
              yraw = response.data[34];
              xorigin = response.data[35];
              yorigin = response.data[36];
              xtop = response.data[37];
              ybottom = response.data[38];
              xbottom = response.data[39];
              ytop = response.data[40];

              coords = [lat,long];
              var ctx=c.getContext("2d");
              //NEEDS REFACTORING
              var imageObjs = [];

              var yt = 0;
              var xt = 0;
              var imgPos = [];

              for (var i = 0; i < 25; i++) {
                imgPos.push([xt,yt]);

                xt = xt + 256;
                if (xt == 1280) {
                  xt = 0;
                  yt = yt + 256;
                }
              }


              for (var i = 0; i < 25; i++) {
                displayTile(i);
              }

              function displayTile(tileNumber) {
                var img = new Image();

                //imageObjs.push(img);
                if (i == 24) {
                  img.crossorigin = 'anonymous';
                  img.onload = function() {
                    ctx.drawImage(img, imgPos[tileNumber][0], imgPos[tileNumber][1]);
                    init();
                  }
                  img.src = pngNames[tileNumber];
                }
                else {
                  //alert(xt + " " + yt);
                  img.crossorigin = 'anonymous';
                  img.onload = function() { ctx.drawImage(img, imgPos[tileNumber][0], imgPos[tileNumber][1]); }
                  img.src = pngNames[tileNumber];
                }
              }

            })
          }

        }
        function onMouseMove( event ) {

        	// calculate mouse position in normalized device coordinates
        	// (-1 to +1) for both components

        	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
          //render();
        }

        function render() {

        	// update the picking ray with the camera and mouse position
        	raycaster.setFromCamera( mouse, camera );

        	// calculate objects intersecting the picking ray
        	var intersects = raycaster.intersectObjects( meshes );

          //alert(intersects);

          if (intersects.length > 0) {
            //alert(intersects[0].distance.toString() + intersects[1].distance.toString());
            //alert(intersects[0].object.material.color.getHexString());



            for (var y = 0; y < intersects[0].object.geometry.faces.length; y++) {
              intersects[0].object.geometry.faces[y].color.setHex( 0x000000 );
            }

            for (var v = 0; v < intersects[0].object.geometry.faces.length; v++) {
              intersects[0].object.geometry.faces[v].colorsNeedUpdate = true;
              intersects[0].object.geometry.faces[v].elementsNeedUpdates = true;
            }
            intersects[0].object.geometry.elementsNeedUpdate = true;
            intersects[0].object.geometry.colorsNeedUpdate = true;
            //alert(intersects[0].object.geometry.faces[0].color.getHexString());
            //intersects[ 0 ].object.material.color.set( 0xff0000 );
            //alert(intersects[0].object.material.color.getHexString());
            //intersects[0].
          }

        	renderer.render( scene, camera );
          hud.style.display = "block";
        }

        function getPost(str) {
          var postJSON = 'https://api.postcodes.io/postcodes/' + str + '/autocomplete'
          $http.get(postJSON)
            .then(function(res) {
              $scope.postcodes = res.data.result;
              for (i = 0; i<$scope.postcodes.length;i++) {
                var option = document.createElement('option');
                option.value = $scope.postcodes[i];
                dataList.appendChild(option);
              }
            });
        }
        function init() {
          if (rebuild) {
            buildModel(statType);
          }
          else {
            buildModel(statType);
            camera = new THREE.PerspectiveCamera( 70, window.pnginnerWidth / window.innerHeight, 1, 10000 );
            camera.position.z = 800;
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            window.addEventListener( 'resize', onWindowResize, false );
            var orbit = new THREE.OrbitControls( camera );
            //console.log(mesh.matrix);
            scene.background = new THREE.Color( 0x000000 );

            window.addEventListener( 'mousemove', onMouseMove, false );

            window.requestAnimationFrame(render);
            finish();
          }

        }
        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }
        function animate() {
          requestAnimationFrame( animate );

          var elapsedTime;
          if (firstFrame == true) {
            scene.scale.y = 0.1;
            mesh.scale.y = 10;
            //alert(firstFrame);
            firstFrame = false;
            elapsedTime = 0;
          }


          elapsedTime++;

          //alert(mesh.position.x)

          //camera.position.x = (mesh.position.x + 1000) * Math.cos(  elapsedTime );
          //camera.position.z = (mesh.position.z + 1000) * Math.sin(  elapsedTime );
          //camera.lookAt( mesh.position );

          if (scene.scale.y < 1) {
            scene.scale.y += 0.01;
          }

          if (scene.scale.y < 0.5) {
            camera.position.x += 10;
            camera.position.y += 10;
            camera.lookAt(mesh.position);
          }

          //alert(camera.position.x);


          mesh.scale.y = 1;

          //position.needsUpdate = true;
          spi.style.display = "none";
          renderer.render( scene, camera );
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }
        function buildModel(modelType) {
          $http({
            method: 'POST',
            url: 'query.php',
            data: { "loc": coords, "type": modelType },
            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
          }).then(function(res) {
            mergedGeo	= new THREE.Geometry();
            var img = c.toDataURL("image/png");
            var texture = new THREE.TextureLoader().load( img );
            var geometry = new THREE.BoxBufferGeometry( 1280, 20, 1280 );
            var material = new THREE.MeshBasicMaterial( { map: texture } );
            group = new THREE.Object3D();
            mesh = new THREE.Mesh( geometry, material );
            scene.add( group );
            postcodeInfo = res.data;
            var longConst = Math.abs(1280 / xspan);
            var latConst = Math.abs(1280 / yspan);
            if (!rebuild) {
              lat = lat - (yoffset);
              long = long - (xoffset);
            }
            group.add(mesh);

            var avg = postcodeInfo[0][0]["Average"];
            var stddev = postcodeInfo[0][0]["Stddev"];
            var max = postcodeInfo[0][0]["Maximum"];

            avg = parseFloat(avg);
            stddev = parseFloat(stddev);
            max = parseFloat(max);

            var upperBound = avg + (stddev * 2);
            upperBound = parseFloat(upperBound);

            //upperBound = upperBound * 3;
            //alert(avg + " " + stddev + " " +  upperBound + " " + max);

            //alert(postcodeInfo[1][0]["Latitude"]);

            //alert(postcodeInfo[1].length);

            //var maxValue = Math.max.apply(Math, nums);

            //alert(maxValue);

            //alert(postcodeInfo.length);
            //alert(mergedGeo);
            for (var i = 1; i < postcodeInfo[1].length; i++) {
            //for (var i = 0; i < 10; i++) {

            //TODO: These checks shouldn't be necessary as query.php should know exactly what data to spit out
              if (postcodeInfo[1][i]["latitude"] < (lat + (yspan / 2)) ) {
                continue;
              }
              if (postcodeInfo[1][i]["longitude"] > (long + (xspan / 2)) ) {
                continue;
              }
              if (postcodeInfo[1][i]["latitude"] > (lat - (yspan / 2)) ) {
                continue;
              }
              if (postcodeInfo[1][i]["longitude"] < (long - (xspan / 2)) ) {
                continue;
              }

              //alert((postcodeInfo[1][i]["Total"] / max) * 200);
              var barGeometry = new THREE.BoxGeometry( 2, (postcodeInfo[1][i]["Total"] / upperBound) * 150, 2 );
              //var barGeometry = new THREE.BoxGeometry( 2, postcodeInfo[1][i]["Total"], 2 );
              var barMaterial 	= new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});
              //var barMaterial 	= new THREE.MeshBasicMaterial();
      				var barMesh	= new THREE.Mesh( barGeometry );
              var rColor, gColor;



              if (postcodeInfo[1][i]["Total"] < upperBound) {
                rColor = postcodeInfo[1][i]["Total"] / upperBound;
              }
              else {
                rColor = 1.0;
              }
              if (postcodeInfo[1][i]["Total"] < upperBound) {
                gColor = 1 - (postcodeInfo[1][i]["Total"] / upperBound);
              }
              else {
                gColor = 0.0;
              }


              //alert(upperBound + " " + postcodeInfo[1][i]["Total"] + " " +  rColor + " " + gColor + " statType= " + modelType + " " + typeof modelType);



              var barColour = new THREE.Color("rgb(" + Math.round(255 * rColor) + "," + Math.round(255 * gColor) + ",0)");

              barMaterial.transparent = true;
              barMaterial.opacity = 0.6;

              //from here
              switch (modelType.toString()) {
                case "0":
                  barMaterial.color.setRGB(1, gColor, 0);
                  break;
                case "1":
                  barMaterial.color.setRGB(1, 0 , gColor);
                  break;
                case "2":
                  barMaterial.color.setRGB(gColor, 1, 0);
                  break;
                case "3":
                  barMaterial.color.setRGB(0, 1, gColor);
                  break;
              }

              //alert(barMaterial.color.getHexString());
              //to here

              //barMaterial.color.setRGB(1, gColor, 0);

              // if (modelType == 1) {
              //   barMaterial.color.setRGB(1, 0 ,gColor);
              // }
              // if (modelType == 0) {
              //   barMaterial.color.setRGB(1, gColor, 0);
              // }


              for ( var z = 0; z < barGeometry.faces.length; z ++ ) {
                  barGeometry.faces[ z ].color = barMaterial.color;
              }

              var xpos = ((((postcodeInfo[1][i]["longitude"] - long ) ) * longConst));
              var ypos = (((postcodeInfo[1][i]["Total"] / upperBound) * 150) / 2);
              var zpos = -((((postcodeInfo[1][i]["latitude"] - lat ) ) * latConst));
              barGeometry.translate(xpos,ypos,zpos);

              //meshes.push(barMesh);

              mergedGeo.mergeMesh(barMesh);

            }

            mergedGeo.computeFaceNormals();
            barGroup	= new THREE.Mesh( mergedGeo, barMaterial );
            //barGroup = new THREE.Mesh(mergedGeo);
            barGroup.matrixAutoUpdate = false;
            barGroup.updateMatrix();
            scene.add(barGroup);
            firstFrame = true;
            animate();

          });
        }
        function finish() {
          $http({
            method: 'POST',
            url: 'cleanup.php',
            data: pngNames,
            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
          }).then(function(res) {
            //alert(res.data);
          });
        }
        // option #1 with ng-change="change()"
        $scope.change = function(str) {
          document.getElementById('json-datalist').innerHTML = '';
          getPost(str);
        }
      });
      </script>


    </body>
</html>
