<meta charset="UTF-8"> 
<html lang="en" ng-app="test" >
    <style>
      body {background-color: black;}
      input[type=text] {
      width: 100%;
      height: 100px;
      padding: 12px 20px;
      margin: 8px 0;
      background-color:rgba(0, 0, 0, 0);
      color:white;
      border: none;
      outline:none;
      font-size:24px;
      text-align: center;
    }
    .button {
      background-color: #111111;
      border: none;
      width: 100%;
      color: white;
      padding: 15px 32px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 16px;
    }
    .center {
      position: absolute;
      left: 50%;
      top: 50%;
      text-align: center;
      width:546px;
      height:265px;
      margin-left: -273px; /*half width*/
      margin-top: -132px; /*half height*/
    }

    .spinner {
      position: absolute;
      left: 50%;
      top: 50%;
      text-align: center;
      width:265px;
      height:265px;
      margin-left: -132px; /*half width*/
      margin-top: -132px; /*half height*/
    }

    .double-bounce1, .double-bounce2 {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background-color: #333;
      opacity: 0.6;
      position: absolute;
      top: 0;
      left: 0;

      -webkit-animation: sk-bounce 2.0s infinite ease-in-out;
      animation: sk-bounce 2.0s infinite ease-in-out;
    }

    .double-bounce2 {
      -webkit-animation-delay: -1.0s;
      animation-delay: -1.0s;
    }

    @-webkit-keyframes sk-bounce {
      0%, 100% { -webkit-transform: scale(0.0) }
      50% { -webkit-transform: scale(1.0) }
    }

    @keyframes sk-bounce {
      0%, 100% {
        transform: scale(0.0);
        -webkit-transform: scale(0.0);
      } 50% {
        transform: scale(1.0);
        -webkit-transform: scale(1.0);
      }
    }
    label
    {
      background-color:#ffffff;
      padding: 5px 12px;
    }

    input[type=radio]
    {
      display:none;
    }
    input[type=radio]:checked + label
    {
      background-color:#8e8e8e;
    }

    </style>
    <body ng-controller="PostCtrl">

      <div id="cont" class="center" style="background-color:black;">

        <input type="text" id="inputajax" list="json-datalist" placeholder="Enter your postcode" ng-change="change(select)" ng-model="select" ng-trim="false">

        <form>
          <input type="radio" id="1" class="rad" name="name" value=0 />
          <label for="1">Population density</label>
          <input type="radio" id="2" class="rad" name="name" value=1 />
          <label for="2">House prices</label>
          <input type="radio" id="3" class="rad" name="name" value=2/>
          <label for="3">Crime</label>
        </form>

        <datalist id="json-datalist"></datalist>

        <button ng-click="test()" class="button">Submit</button>

      </div>
      <div hidden>
            <canvas id="myCanvas" width="1280" height="1280" crossOrigin="anonymous"></canvas>
      </div>

      <div id="spin" class="spinner">
        <div class="double-bounce1"></div>
        <div class="double-bounce2"></div>
      </div>
      <script>
      var spi = document.getElementById('spin');
      spi.style.display = "none";
      </script>
      <script src="../tjs/build/three.js"></script>
      <script src="../tjs/examples/js/controls/OrbitControls.js"></script>
      <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js"></script>


      <!-- from here -->
      <script>
      var app = angular.module('test', []);
      var input = document.getElementById('inputajax');
      var container = document.getElementById('cont');
      var dataList = document.getElementById('json-datalist');
      var camera, scene, renderer;
      var mesh;
      var coords;
      var c=document.getElementById("myCanvas");
      var postcodeInfo;
      var lat, long;
      var xoffset, yoffset, xspan, yspan;
      var xtop, ytop, xbottom, ybottom;
      var pngNames = [];
      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();
      var meshes = [];
      var mergedGeo;
      var firstFrame;
      var spi = document.getElementById('spin');

      var statType;



      //var mergedGeo;
      app.controller('PostCtrl', function($scope, $http) {
        $scope.select = "";
        $scope.test = function() {
          var val = document.getElementById('inputajax').value;
          spi.style.display = "block";
          container.style.display = "none";

          var selection = document.forms[0];

          for (var i = 0; i < selection.length; i++) {
            //alert(selection[i].value);
            if (selection[i].checked) {
              statType = selection[i].value;
            }
          }
          //alert(statType);

          $http({
            method: 'POST',
            url: 'init.php',
            data: val,
            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
          }).then(function(response) {
            console.log(response);

            for (var i = 0; i < 25; i++) {
              pngNames.push(response.data[i])
            }
            lat = response.data[25];
            long = response.data[26];
            xoffset = response.data[27];
            yoffset = response.data[28];
            xspan = response.data[29];
            yspan = response.data[30];
            xtile = response.data[31];
            ytile = response.data[32];
            xraw = response.data[33];
            yraw = response.data[34];
            xorigin = response.data[35];
            yorigin = response.data[36];
            xtop = response.data[37];
            ybottom = response.data[38];
            xbottom = response.data[39];
            ytop = response.data[40];

            coords = [lat,long];
            var ctx=c.getContext("2d");
            //NEEDS REFACTORING
            var imageObjs = [];

            var yt = 0;
            var xt = 0;
            var imgPos = [];

            for (var i = 0; i < 25; i++) {
              imgPos.push([xt,yt]);

              xt = xt + 256;
              if (xt == 1280) {
                xt = 0;
                yt = yt + 256;
              }
            }


            for (var i = 0; i < 25; i++) {
              displayTile(i);
            }

            function displayTile(tileNumber) {
              var img = new Image();

              //imageObjs.push(img);
              if (i == 24) {
                img.crossorigin = 'anonymous';
                img.onload = function() {
                  ctx.drawImage(img, imgPos[tileNumber][0], imgPos[tileNumber][1]);
                  init();
                }
                img.src = pngNames[tileNumber];
              }
              else {
                //alert(xt + " " + yt);
                img.crossorigin = 'anonymous';
                img.onload = function() { ctx.drawImage(img, imgPos[tileNumber][0], imgPos[tileNumber][1]); }
                img.src = pngNames[tileNumber];
              }
            }

          })
        }
        function onMouseMove( event ) {

        	// calculate mouse position in normalized device coordinates
        	// (-1 to +1) for both components

        	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
          //render();
        }

        function render() {

        	// update the picking ray with the camera and mouse position
        	raycaster.setFromCamera( mouse, camera );

        	// calculate objects intersecting the picking ray
        	var intersects = raycaster.intersectObjects( meshes );

          //alert(intersects);

          if (intersects.length > 0) {
            //alert(intersects[0].distance.toString() + intersects[1].distance.toString());
            //alert(intersects[0].object.material.color.getHexString());



            for (var y = 0; y < intersects[0].object.geometry.faces.length; y++) {
              intersects[0].object.geometry.faces[y].color.setHex( 0x000000 );
            }

            for (var v = 0; v < intersects[0].object.geometry.faces.length; v++) {
              intersects[0].object.geometry.faces[v].colorsNeedUpdate = true;
              intersects[0].object.geometry.faces[v].elementsNeedUpdates = true;
            }
            intersects[0].object.geometry.elementsNeedUpdate = true;
            intersects[0].object.geometry.colorsNeedUpdate = true;
            //alert(intersects[0].object.geometry.faces[0].color.getHexString());
            //intersects[ 0 ].object.material.color.set( 0xff0000 );
            //alert(intersects[0].object.material.color.getHexString());
            //intersects[0].
          }

        	renderer.render( scene, camera );

        }

        function getPost(str) {
          var postJSON = 'https://api.postcodes.io/postcodes/' + str + '/autocomplete'
          $http.get(postJSON)
            .then(function(res) {
              $scope.postcodes = res.data.result;
              for (i = 0; i<$scope.postcodes.length;i++) {
                var option = document.createElement('option');
                option.value = $scope.postcodes[i];
                dataList.appendChild(option);
              }
            });
        }
        function init() {
          buildModel(statType);
          camera = new THREE.PerspectiveCamera( 70, window.pnginnerWidth / window.innerHeight, 1, 10000 );
          camera.position.z = 800;
          scene = new THREE.Scene();
          renderer = new THREE.WebGLRenderer({ alpha: true });
          renderer.setPixelRatio( window.devicePixelRatio );
          renderer.setSize( window.innerWidth, window.innerHeight );
          document.body.appendChild( renderer.domElement );
          window.addEventListener( 'resize', onWindowResize, false );
          var orbit = new THREE.OrbitControls( camera );
          //console.log(mesh.matrix);
          scene.background = new THREE.Color( 0x000000 );

          window.addEventListener( 'mousemove', onMouseMove, false );

          window.requestAnimationFrame(render);
          finish();
        }
        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }
        function animate() {
          requestAnimationFrame( animate );

          var elapsedTime;
          if (firstFrame == true) {
            scene.scale.y = 0.1;
            mesh.scale.y = 10;
            //alert(firstFrame);
            firstFrame = false;
            elapsedTime = 0;
          }


          elapsedTime++;

          //alert(mesh.position.x)

          //camera.position.x = (mesh.position.x + 1000) * Math.cos(  elapsedTime );
          //camera.position.z = (mesh.position.z + 1000) * Math.sin(  elapsedTime );
          //camera.lookAt( mesh.position );

          if (scene.scale.y < 1) {
            scene.scale.y += 0.01;
          }

          if (scene.scale.y < 0.5) {
            camera.position.x += 10;
            camera.position.y += 10;
            camera.lookAt(mesh.position);
          }

          //alert(camera.position.x);


          mesh.scale.y = 1;

          //position.needsUpdate = true;
          spi.style.display = "none";
          renderer.render( scene, camera );
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
        }
        function buildModel(modelType) {
          $http({
            method: 'POST',
            url: 'query.php',
            data: { "loc": coords, "type": modelType },
            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
          }).then(function(res) {
            mergedGeo	= new THREE.Geometry();
            var img = c.toDataURL("image/png");
            var texture = new THREE.TextureLoader().load( img );
            var geometry = new THREE.BoxBufferGeometry( 1280, 20, 1280 );
            var material = new THREE.MeshBasicMaterial( { map: texture } );
            group = new THREE.Object3D();
            mesh = new THREE.Mesh( geometry, material );
            scene.add( group );
            postcodeInfo = res.data;
            var longConst = Math.abs(1280 / xspan);
            var latConst = Math.abs(1280 / yspan);
            lat = lat - (yoffset);
            long = long - (xoffset);
            group.add(mesh);

            //alert(postcodeInfo.length);
            //alert(mergedGeo);
            for (var i = 0; i < postcodeInfo.length; i++) {
            //for (var i = 0; i < 10; i++) {

            //TODO: These checks shouldn't be necessary as query.php should know exactly what data to spit out
              if (postcodeInfo[i]["Latitude"] < (lat + (yspan / 2)) ) {
                continue;
              }
              if (postcodeInfo[i]["Longitude"] > (long + (xspan / 2)) ) {
                continue;
              }
              if (postcodeInfo[i]["Latitude"] > (lat - (yspan / 2)) ) {
                continue;
              }
              if (postcodeInfo[i]["Longitude"] < (long - (xspan / 2)) ) {
                continue;
              }
              var barGeometry = new THREE.BoxGeometry( 2, postcodeInfo[i]["Total"], 2 );
              var barMaterial 	= new THREE.MeshBasicMaterial({vertexColors: THREE.VertexColors});
              //var barMaterial 	= new THREE.MeshBasicMaterial();
      				var barMesh	= new THREE.Mesh( barGeometry );
              var rColor, gColor;
              if (postcodeInfo[i]["Total"] < 150) {
                rColor = postcodeInfo[i]["Total"] / 150;
              }
              else {
                rColor = 1.0;
              }
              if (postcodeInfo[i]["Total"] < 150) {
                gColor = 1 - (postcodeInfo[i]["Total"] / 150);
              }
              else {
                gColor = 0.0;
              }

              var barColour = new THREE.Color("rgb(" + Math.round(255 * rColor) + "," + Math.round(255 * gColor) + ",0)");

              barMaterial.transparent = true;
              barMaterial.opacity = 0.6;

              //from here
              switch (modelType) {
               case "0":
                 barMaterial.color.setRGB(1, gColor, 0);
                 break;
               case "1":
                 barMaterial.color.setRGB(1, 0 , gColor);
                 break;
              }
              //to here

              //barMaterial.color.setRGB(1, gColor, 0);

              // if (modelType == 1) {
              //   barMaterial.color.setRGB(1, 0 ,gColor);
              // }
              // if (modelType == 0) {
              //   barMaterial.color.setRGB(1, gColor, 0);
              // }


              for ( var z = 0; z < barGeometry.faces.length; z ++ ) {
                  barGeometry.faces[ z ].color = barMaterial.color;
              }

              var xpos = ((((postcodeInfo[i]["Longitude"] - long ) ) * longConst));
              var ypos = (postcodeInfo[i]["Total"] / 2);
              var zpos = -((((postcodeInfo[i]["Latitude"] - lat ) ) * latConst));
              barGeometry.translate(xpos,ypos,zpos);

              meshes.push(barMesh);

              mergedGeo.mergeMesh(barMesh);

            }

            mergedGeo.computeFaceNormals();
            barGroup	= new THREE.Mesh( mergedGeo, barMaterial );
            //barGroup = new THREE.Mesh(mergedGeo);
            barGroup.matrixAutoUpdate = false;
            barGroup.updateMatrix();
            scene.add(barGroup);
            firstFrame = true;
            animate();

          });
        }
        function finish() {
          $http({
            method: 'POST',
            url: 'cleanup.php',
            data: pngNames,
            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
          }).then(function(res) {
            //alert(res.data);
          });
        }
        // option #1 with ng-change="change()"
        $scope.change = function(str) {
          document.getElementById('json-datalist').innerHTML = '';
          getPost(str);
        }
      });
      </script>


    </body>
</html>
